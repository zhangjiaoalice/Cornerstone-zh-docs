# Rendering Loop (循环渲染)
*Cornerstone 的影像图片容器的视口的更新操作（如平移、缩放、旋转）是基于 `requestAnimationFrame` API 进行更新渲染的*
* 循环渲染是浏览器用来持续重绘或者重新呈现网页内容的过程，当网页中 DOM 元素的大小、位置、颜色发生变化的时候，浏览器会重新绘制变更的部分，确保网页内容能被正确显示
***

## Rendering Loop 工作流程
* 在大多数的现代浏览器中，提供了 `requestAnimationFrame` API, 允许开发者在下一次重绘之前调用特定的函数，从而实现平滑的动画效果，如果 浏览器不支持 `requestAnimationFrame` 这个 API， 则需要基于 `setTimeout、setInterval` 的 16毫秒定时器来模拟 `requestAnimation` 的效果。
    * 使用定时器设置一个 16毫秒的回调，当这个回调被触发时，会执行相应的更新操作。然后使用 `clearTimeout、clearInterval` 清除定时器，为下一次的更新做准备
* 循环渲染与Cornerstone 库一起使用的时候，元素的渲染循环是单独启用或者禁用的，这意味着开发者可以控制哪些元素使用循环渲染来提高渲染性能或者优化某些特定的情况

#### 具体流程
1. 向 `requestAnimationFrame` API 中添加一个`draw()` 的回调;
2. 浏览器在渲染页面时，会将每一帧的画面绘制到屏幕上，在绘制完一帧画面之后，会立即调用 `draw()` 回调
3. `draw()` 方法调用之后:
    * 如果某个元素(属性、数据发生变化)需要被重新绘制或者更新，浏览器会根据当前元素的属性和状态来重新绘制它，当元素被重新渲染之后，`draw()` 回调会被重新注册到 `requestAnimationFrame`中，在下一次重新绘制之前会被调用
    * 如果当前元素的状态没有发生变化，不需要重新绘制，浏览器不会执行任何渲染相关的操作，即使没有执行更新但是，`draw()` 仍然会被注册到 `requestAnimationFrame()` 中，这样就确保了在需要重新渲染元素的时候，`draw()` 仍然能在正确的时机被调用，从而能够快速的响应并更新页面
    * 如果当前的元素被禁用了，`draw()` 不会被注册到 `requestAnimationFrame` 中，结束渲染

## 使用渲染需要关注的问题
1. 在调用 `draw()` 和 `invalidate()` 方法的时候，不会立即出发视口(viewport)的更新，这两个方法用于标记图像的状态，告诉浏览器在将来的某个时间点需要渲染这个图像。这样可以有效的管理渲染资源，并在正确的时机进行渲染操作
2. 每个 Cornerstone 元素都注册了自己的 `resquestAnimationFrame`, 通过注册 RFA 循环，可以确保在浏览器重绘之前更新元素的状态，从而提供流畅的动画效果
3. 在屏刷率为 60Hz 的系统上，如果渲染时间超过 16 毫秒，就会跳过渲染帧（浏览器会跳过那些由于渲染时间过长而无法在16毫秒内完成的帧以确保流畅的动画效果）。这样可以避免因长时间渲染操作导致的动画卡顿或者延迟。
4. 即使渲染的时间很短，每个帧也只能进行一次渲染操作。这意味着浏览器不会在单个帧内执行多次渲染，以确保动画的流畅性
5. 当用户与页面进行交互的时候，所有的交互（平移、缩放、旋转）不会立即在当前帧中渲染，而是被收集在下一帧中一起渲染.这样可以确保交互的流畅性和性能。




